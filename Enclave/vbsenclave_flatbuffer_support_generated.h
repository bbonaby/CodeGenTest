// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VBSENCLAVEFLATBUFFERSUPPORT_FLATBUFFERSDEVTYPES_H_
#define FLATBUFFERS_GENERATED_VBSENCLAVEFLATBUFFERSUPPORT_FLATBUFFERSDEVTYPES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace FlatbuffersDevTypes {

struct TestStruct1;
struct TestStruct1Builder;
struct TestStruct1T;

struct NestedStructWithPointers;
struct NestedStructWithPointersBuilder;
struct NestedStructWithPointersT;

struct StructWithPointers;
struct StructWithPointersBuilder;
struct StructWithPointersT;

struct TestFunc0_args;
struct TestFunc0_argsBuilder;
struct TestFunc0_argsT;

struct TestFunc1_args;
struct TestFunc1_argsBuilder;
struct TestFunc1_argsT;

struct WString;
struct WStringBuilder;
struct WStringT;

struct AbiRegisterVtl0Callbacks_args;
struct AbiRegisterVtl0Callbacks_argsBuilder;
struct AbiRegisterVtl0Callbacks_argsT;

struct __root_table;
struct __root_tableBuilder;
struct __root_tableT;

struct TestStruct1T : public ::flatbuffers::NativeTable {
  typedef TestStruct1 TableType;
  int64_t int64_val = 0;
  uint64_t uint64_val = 0;
  std::vector<int64_t> array1{};
};

struct TestStruct1 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TestStruct1T NativeTableType;
  typedef TestStruct1Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INT64_VAL = 4,
    VT_UINT64_VAL = 6,
    VT_ARRAY1 = 8
  };
  int64_t int64_val() const {
    return GetField<int64_t>(VT_INT64_VAL, 0);
  }
  uint64_t uint64_val() const {
    return GetField<uint64_t>(VT_UINT64_VAL, 0);
  }
  const ::flatbuffers::Vector<int64_t> *array1() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_ARRAY1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_INT64_VAL, 8) &&
           VerifyField<uint64_t>(verifier, VT_UINT64_VAL, 8) &&
           VerifyOffset(verifier, VT_ARRAY1) &&
           verifier.VerifyVector(array1()) &&
           verifier.EndTable();
  }
  TestStruct1T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TestStruct1T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TestStruct1> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TestStruct1T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TestStruct1Builder {
  typedef TestStruct1 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_int64_val(int64_t int64_val) {
    fbb_.AddElement<int64_t>(TestStruct1::VT_INT64_VAL, int64_val, 0);
  }
  void add_uint64_val(uint64_t uint64_val) {
    fbb_.AddElement<uint64_t>(TestStruct1::VT_UINT64_VAL, uint64_val, 0);
  }
  void add_array1(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> array1) {
    fbb_.AddOffset(TestStruct1::VT_ARRAY1, array1);
  }
  explicit TestStruct1Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TestStruct1> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TestStruct1>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TestStruct1> CreateTestStruct1(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t int64_val = 0,
    uint64_t uint64_val = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> array1 = 0) {
  TestStruct1Builder builder_(_fbb);
  builder_.add_uint64_val(uint64_val);
  builder_.add_int64_val(int64_val);
  builder_.add_array1(array1);
  return builder_.Finish();
}

struct TestStruct1::Traits {
  using type = TestStruct1;
  static auto constexpr Create = CreateTestStruct1;
};

inline ::flatbuffers::Offset<TestStruct1> CreateTestStruct1Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t int64_val = 0,
    uint64_t uint64_val = 0,
    const std::vector<int64_t> *array1 = nullptr) {
  auto array1__ = array1 ? _fbb.CreateVector<int64_t>(*array1) : 0;
  return FlatbuffersDevTypes::CreateTestStruct1(
      _fbb,
      int64_val,
      uint64_val,
      array1__);
}

::flatbuffers::Offset<TestStruct1> CreateTestStruct1(::flatbuffers::FlatBufferBuilder &_fbb, const TestStruct1T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NestedStructWithPointersT : public ::flatbuffers::NativeTable {
  typedef NestedStructWithPointers TableType;
  ::flatbuffers::Optional<int32_t> int32_ptr = ::flatbuffers::nullopt;
  std::unique_ptr<FlatbuffersDevTypes::TestStruct1T> struct_ptr{};
  NestedStructWithPointersT() = default;
  NestedStructWithPointersT(const NestedStructWithPointersT &o);
  NestedStructWithPointersT(NestedStructWithPointersT&&) FLATBUFFERS_NOEXCEPT = default;
  NestedStructWithPointersT &operator=(NestedStructWithPointersT o) FLATBUFFERS_NOEXCEPT;
};

struct NestedStructWithPointers FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NestedStructWithPointersT NativeTableType;
  typedef NestedStructWithPointersBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INT32_PTR = 4,
    VT_STRUCT_PTR = 6
  };
  ::flatbuffers::Optional<int32_t> int32_ptr() const {
    return GetOptional<int32_t, int32_t>(VT_INT32_PTR);
  }
  const FlatbuffersDevTypes::TestStruct1 *struct_ptr() const {
    return GetPointer<const FlatbuffersDevTypes::TestStruct1 *>(VT_STRUCT_PTR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INT32_PTR, 4) &&
           VerifyOffset(verifier, VT_STRUCT_PTR) &&
           verifier.VerifyTable(struct_ptr()) &&
           verifier.EndTable();
  }
  NestedStructWithPointersT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NestedStructWithPointersT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NestedStructWithPointers> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NestedStructWithPointersT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NestedStructWithPointersBuilder {
  typedef NestedStructWithPointers Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_int32_ptr(int32_t int32_ptr) {
    fbb_.AddElement<int32_t>(NestedStructWithPointers::VT_INT32_PTR, int32_ptr);
  }
  void add_struct_ptr(::flatbuffers::Offset<FlatbuffersDevTypes::TestStruct1> struct_ptr) {
    fbb_.AddOffset(NestedStructWithPointers::VT_STRUCT_PTR, struct_ptr);
  }
  explicit NestedStructWithPointersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NestedStructWithPointers> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NestedStructWithPointers>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NestedStructWithPointers> CreateNestedStructWithPointers(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Optional<int32_t> int32_ptr = ::flatbuffers::nullopt,
    ::flatbuffers::Offset<FlatbuffersDevTypes::TestStruct1> struct_ptr = 0) {
  NestedStructWithPointersBuilder builder_(_fbb);
  builder_.add_struct_ptr(struct_ptr);
  if(int32_ptr) { builder_.add_int32_ptr(*int32_ptr); }
  return builder_.Finish();
}

struct NestedStructWithPointers::Traits {
  using type = NestedStructWithPointers;
  static auto constexpr Create = CreateNestedStructWithPointers;
};

::flatbuffers::Offset<NestedStructWithPointers> CreateNestedStructWithPointers(::flatbuffers::FlatBufferBuilder &_fbb, const NestedStructWithPointersT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StructWithPointersT : public ::flatbuffers::NativeTable {
  typedef StructWithPointers TableType;
  std::unique_ptr<FlatbuffersDevTypes::NestedStructWithPointersT> nested_struct_ptr{};
  StructWithPointersT() = default;
  StructWithPointersT(const StructWithPointersT &o);
  StructWithPointersT(StructWithPointersT&&) FLATBUFFERS_NOEXCEPT = default;
  StructWithPointersT &operator=(StructWithPointersT o) FLATBUFFERS_NOEXCEPT;
};

struct StructWithPointers FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StructWithPointersT NativeTableType;
  typedef StructWithPointersBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NESTED_STRUCT_PTR = 4
  };
  const FlatbuffersDevTypes::NestedStructWithPointers *nested_struct_ptr() const {
    return GetPointer<const FlatbuffersDevTypes::NestedStructWithPointers *>(VT_NESTED_STRUCT_PTR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NESTED_STRUCT_PTR) &&
           verifier.VerifyTable(nested_struct_ptr()) &&
           verifier.EndTable();
  }
  StructWithPointersT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StructWithPointersT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StructWithPointers> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StructWithPointersT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StructWithPointersBuilder {
  typedef StructWithPointers Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nested_struct_ptr(::flatbuffers::Offset<FlatbuffersDevTypes::NestedStructWithPointers> nested_struct_ptr) {
    fbb_.AddOffset(StructWithPointers::VT_NESTED_STRUCT_PTR, nested_struct_ptr);
  }
  explicit StructWithPointersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StructWithPointers> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StructWithPointers>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StructWithPointers> CreateStructWithPointers(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<FlatbuffersDevTypes::NestedStructWithPointers> nested_struct_ptr = 0) {
  StructWithPointersBuilder builder_(_fbb);
  builder_.add_nested_struct_ptr(nested_struct_ptr);
  return builder_.Finish();
}

struct StructWithPointers::Traits {
  using type = StructWithPointers;
  static auto constexpr Create = CreateStructWithPointers;
};

::flatbuffers::Offset<StructWithPointers> CreateStructWithPointers(::flatbuffers::FlatBufferBuilder &_fbb, const StructWithPointersT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TestFunc0_argsT : public ::flatbuffers::NativeTable {
  typedef TestFunc0_args TableType;
  int32_t m__return_value_ = 0;
  bool m_arg1 = false;
  ::flatbuffers::Optional<uint32_t> m_arg2 = ::flatbuffers::nullopt;
  ::flatbuffers::Optional<int32_t> m_arg3 = ::flatbuffers::nullopt;
  ::flatbuffers::Optional<uint64_t> m_arg4 = ::flatbuffers::nullopt;
  std::unique_ptr<FlatbuffersDevTypes::StructWithPointersT> m_arg5{};
  std::unique_ptr<FlatbuffersDevTypes::StructWithPointersT> m_arg6{};
  std::vector<FlatbuffersDevTypes::StructWithPointersT> m_arg7{};
  std::vector<int16_t> m_arg8{};
  std::vector<FlatbuffersDevTypes::WStringT> m_arg9{};
  TestFunc0_argsT() = default;
  TestFunc0_argsT(const TestFunc0_argsT &o);
  TestFunc0_argsT(TestFunc0_argsT&&) FLATBUFFERS_NOEXCEPT = default;
  TestFunc0_argsT &operator=(TestFunc0_argsT o) FLATBUFFERS_NOEXCEPT;
};

struct TestFunc0_args FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TestFunc0_argsT NativeTableType;
  typedef TestFunc0_argsBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M__RETURN_VALUE_ = 4,
    VT_M_ARG1 = 6,
    VT_M_ARG2 = 8,
    VT_M_ARG3 = 10,
    VT_M_ARG4 = 12,
    VT_M_ARG5 = 14,
    VT_M_ARG6 = 16,
    VT_M_ARG7 = 18,
    VT_M_ARG8 = 20,
    VT_M_ARG9 = 22
  };
  int32_t m__return_value_() const {
    return GetField<int32_t>(VT_M__RETURN_VALUE_, 0);
  }
  bool m_arg1() const {
    return GetField<uint8_t>(VT_M_ARG1, 0) != 0;
  }
  ::flatbuffers::Optional<uint32_t> m_arg2() const {
    return GetOptional<uint32_t, uint32_t>(VT_M_ARG2);
  }
  ::flatbuffers::Optional<int32_t> m_arg3() const {
    return GetOptional<int32_t, int32_t>(VT_M_ARG3);
  }
  ::flatbuffers::Optional<uint64_t> m_arg4() const {
    return GetOptional<uint64_t, uint64_t>(VT_M_ARG4);
  }
  const FlatbuffersDevTypes::StructWithPointers *m_arg5() const {
    return GetPointer<const FlatbuffersDevTypes::StructWithPointers *>(VT_M_ARG5);
  }
  const FlatbuffersDevTypes::StructWithPointers *m_arg6() const {
    return GetPointer<const FlatbuffersDevTypes::StructWithPointers *>(VT_M_ARG6);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers>> *m_arg7() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers>> *>(VT_M_ARG7);
  }
  const ::flatbuffers::Vector<int16_t> *m_arg8() const {
    return GetPointer<const ::flatbuffers::Vector<int16_t> *>(VT_M_ARG8);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FlatbuffersDevTypes::WString>> *m_arg9() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FlatbuffersDevTypes::WString>> *>(VT_M_ARG9);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_M__RETURN_VALUE_, 4) &&
           VerifyField<uint8_t>(verifier, VT_M_ARG1, 1) &&
           VerifyField<uint32_t>(verifier, VT_M_ARG2, 4) &&
           VerifyField<int32_t>(verifier, VT_M_ARG3, 4) &&
           VerifyField<uint64_t>(verifier, VT_M_ARG4, 8) &&
           VerifyOffset(verifier, VT_M_ARG5) &&
           verifier.VerifyTable(m_arg5()) &&
           VerifyOffset(verifier, VT_M_ARG6) &&
           verifier.VerifyTable(m_arg6()) &&
           VerifyOffset(verifier, VT_M_ARG7) &&
           verifier.VerifyVector(m_arg7()) &&
           verifier.VerifyVectorOfTables(m_arg7()) &&
           VerifyOffset(verifier, VT_M_ARG8) &&
           verifier.VerifyVector(m_arg8()) &&
           VerifyOffset(verifier, VT_M_ARG9) &&
           verifier.VerifyVector(m_arg9()) &&
           verifier.VerifyVectorOfTables(m_arg9()) &&
           verifier.EndTable();
  }
  TestFunc0_argsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TestFunc0_argsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TestFunc0_args> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TestFunc0_argsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TestFunc0_argsBuilder {
  typedef TestFunc0_args Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_m__return_value_(int32_t m__return_value_) {
    fbb_.AddElement<int32_t>(TestFunc0_args::VT_M__RETURN_VALUE_, m__return_value_, 0);
  }
  void add_m_arg1(bool m_arg1) {
    fbb_.AddElement<uint8_t>(TestFunc0_args::VT_M_ARG1, static_cast<uint8_t>(m_arg1), 0);
  }
  void add_m_arg2(uint32_t m_arg2) {
    fbb_.AddElement<uint32_t>(TestFunc0_args::VT_M_ARG2, m_arg2);
  }
  void add_m_arg3(int32_t m_arg3) {
    fbb_.AddElement<int32_t>(TestFunc0_args::VT_M_ARG3, m_arg3);
  }
  void add_m_arg4(uint64_t m_arg4) {
    fbb_.AddElement<uint64_t>(TestFunc0_args::VT_M_ARG4, m_arg4);
  }
  void add_m_arg5(::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers> m_arg5) {
    fbb_.AddOffset(TestFunc0_args::VT_M_ARG5, m_arg5);
  }
  void add_m_arg6(::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers> m_arg6) {
    fbb_.AddOffset(TestFunc0_args::VT_M_ARG6, m_arg6);
  }
  void add_m_arg7(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers>>> m_arg7) {
    fbb_.AddOffset(TestFunc0_args::VT_M_ARG7, m_arg7);
  }
  void add_m_arg8(::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> m_arg8) {
    fbb_.AddOffset(TestFunc0_args::VT_M_ARG8, m_arg8);
  }
  void add_m_arg9(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FlatbuffersDevTypes::WString>>> m_arg9) {
    fbb_.AddOffset(TestFunc0_args::VT_M_ARG9, m_arg9);
  }
  explicit TestFunc0_argsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TestFunc0_args> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TestFunc0_args>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TestFunc0_args> CreateTestFunc0_args(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t m__return_value_ = 0,
    bool m_arg1 = false,
    ::flatbuffers::Optional<uint32_t> m_arg2 = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<int32_t> m_arg3 = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<uint64_t> m_arg4 = ::flatbuffers::nullopt,
    ::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers> m_arg5 = 0,
    ::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers> m_arg6 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers>>> m_arg7 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> m_arg8 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FlatbuffersDevTypes::WString>>> m_arg9 = 0) {
  TestFunc0_argsBuilder builder_(_fbb);
  if(m_arg4) { builder_.add_m_arg4(*m_arg4); }
  builder_.add_m_arg9(m_arg9);
  builder_.add_m_arg8(m_arg8);
  builder_.add_m_arg7(m_arg7);
  builder_.add_m_arg6(m_arg6);
  builder_.add_m_arg5(m_arg5);
  if(m_arg3) { builder_.add_m_arg3(*m_arg3); }
  if(m_arg2) { builder_.add_m_arg2(*m_arg2); }
  builder_.add_m__return_value_(m__return_value_);
  builder_.add_m_arg1(m_arg1);
  return builder_.Finish();
}

struct TestFunc0_args::Traits {
  using type = TestFunc0_args;
  static auto constexpr Create = CreateTestFunc0_args;
};

inline ::flatbuffers::Offset<TestFunc0_args> CreateTestFunc0_argsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t m__return_value_ = 0,
    bool m_arg1 = false,
    ::flatbuffers::Optional<uint32_t> m_arg2 = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<int32_t> m_arg3 = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<uint64_t> m_arg4 = ::flatbuffers::nullopt,
    ::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers> m_arg5 = 0,
    ::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers> m_arg6 = 0,
    const std::vector<::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers>> *m_arg7 = nullptr,
    const std::vector<int16_t> *m_arg8 = nullptr,
    const std::vector<::flatbuffers::Offset<FlatbuffersDevTypes::WString>> *m_arg9 = nullptr) {
  auto m_arg7__ = m_arg7 ? _fbb.CreateVector<::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers>>(*m_arg7) : 0;
  auto m_arg8__ = m_arg8 ? _fbb.CreateVector<int16_t>(*m_arg8) : 0;
  auto m_arg9__ = m_arg9 ? _fbb.CreateVector<::flatbuffers::Offset<FlatbuffersDevTypes::WString>>(*m_arg9) : 0;
  return FlatbuffersDevTypes::CreateTestFunc0_args(
      _fbb,
      m__return_value_,
      m_arg1,
      m_arg2,
      m_arg3,
      m_arg4,
      m_arg5,
      m_arg6,
      m_arg7__,
      m_arg8__,
      m_arg9__);
}

::flatbuffers::Offset<TestFunc0_args> CreateTestFunc0_args(::flatbuffers::FlatBufferBuilder &_fbb, const TestFunc0_argsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TestFunc1_argsT : public ::flatbuffers::NativeTable {
  typedef TestFunc1_args TableType;
  int32_t m__return_value_ = 0;
  bool m_arg1 = false;
  ::flatbuffers::Optional<uint32_t> m_arg2 = ::flatbuffers::nullopt;
  ::flatbuffers::Optional<int32_t> m_arg3 = ::flatbuffers::nullopt;
  ::flatbuffers::Optional<uint64_t> m_arg4 = ::flatbuffers::nullopt;
  std::unique_ptr<FlatbuffersDevTypes::StructWithPointersT> m_arg5{};
  std::unique_ptr<FlatbuffersDevTypes::StructWithPointersT> m_arg6{};
  std::vector<FlatbuffersDevTypes::StructWithPointersT> m_arg7{};
  std::vector<int16_t> m_arg8{};
  std::vector<FlatbuffersDevTypes::WStringT> m_arg9{};
  TestFunc1_argsT() = default;
  TestFunc1_argsT(const TestFunc1_argsT &o);
  TestFunc1_argsT(TestFunc1_argsT&&) FLATBUFFERS_NOEXCEPT = default;
  TestFunc1_argsT &operator=(TestFunc1_argsT o) FLATBUFFERS_NOEXCEPT;
};

struct TestFunc1_args FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TestFunc1_argsT NativeTableType;
  typedef TestFunc1_argsBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M__RETURN_VALUE_ = 4,
    VT_M_ARG1 = 6,
    VT_M_ARG2 = 8,
    VT_M_ARG3 = 10,
    VT_M_ARG4 = 12,
    VT_M_ARG5 = 14,
    VT_M_ARG6 = 16,
    VT_M_ARG7 = 18,
    VT_M_ARG8 = 20,
    VT_M_ARG9 = 22
  };
  int32_t m__return_value_() const {
    return GetField<int32_t>(VT_M__RETURN_VALUE_, 0);
  }
  bool m_arg1() const {
    return GetField<uint8_t>(VT_M_ARG1, 0) != 0;
  }
  ::flatbuffers::Optional<uint32_t> m_arg2() const {
    return GetOptional<uint32_t, uint32_t>(VT_M_ARG2);
  }
  ::flatbuffers::Optional<int32_t> m_arg3() const {
    return GetOptional<int32_t, int32_t>(VT_M_ARG3);
  }
  ::flatbuffers::Optional<uint64_t> m_arg4() const {
    return GetOptional<uint64_t, uint64_t>(VT_M_ARG4);
  }
  const FlatbuffersDevTypes::StructWithPointers *m_arg5() const {
    return GetPointer<const FlatbuffersDevTypes::StructWithPointers *>(VT_M_ARG5);
  }
  const FlatbuffersDevTypes::StructWithPointers *m_arg6() const {
    return GetPointer<const FlatbuffersDevTypes::StructWithPointers *>(VT_M_ARG6);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers>> *m_arg7() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers>> *>(VT_M_ARG7);
  }
  const ::flatbuffers::Vector<int16_t> *m_arg8() const {
    return GetPointer<const ::flatbuffers::Vector<int16_t> *>(VT_M_ARG8);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FlatbuffersDevTypes::WString>> *m_arg9() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FlatbuffersDevTypes::WString>> *>(VT_M_ARG9);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_M__RETURN_VALUE_, 4) &&
           VerifyField<uint8_t>(verifier, VT_M_ARG1, 1) &&
           VerifyField<uint32_t>(verifier, VT_M_ARG2, 4) &&
           VerifyField<int32_t>(verifier, VT_M_ARG3, 4) &&
           VerifyField<uint64_t>(verifier, VT_M_ARG4, 8) &&
           VerifyOffset(verifier, VT_M_ARG5) &&
           verifier.VerifyTable(m_arg5()) &&
           VerifyOffset(verifier, VT_M_ARG6) &&
           verifier.VerifyTable(m_arg6()) &&
           VerifyOffset(verifier, VT_M_ARG7) &&
           verifier.VerifyVector(m_arg7()) &&
           verifier.VerifyVectorOfTables(m_arg7()) &&
           VerifyOffset(verifier, VT_M_ARG8) &&
           verifier.VerifyVector(m_arg8()) &&
           VerifyOffset(verifier, VT_M_ARG9) &&
           verifier.VerifyVector(m_arg9()) &&
           verifier.VerifyVectorOfTables(m_arg9()) &&
           verifier.EndTable();
  }
  TestFunc1_argsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TestFunc1_argsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TestFunc1_args> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TestFunc1_argsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TestFunc1_argsBuilder {
  typedef TestFunc1_args Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_m__return_value_(int32_t m__return_value_) {
    fbb_.AddElement<int32_t>(TestFunc1_args::VT_M__RETURN_VALUE_, m__return_value_, 0);
  }
  void add_m_arg1(bool m_arg1) {
    fbb_.AddElement<uint8_t>(TestFunc1_args::VT_M_ARG1, static_cast<uint8_t>(m_arg1), 0);
  }
  void add_m_arg2(uint32_t m_arg2) {
    fbb_.AddElement<uint32_t>(TestFunc1_args::VT_M_ARG2, m_arg2);
  }
  void add_m_arg3(int32_t m_arg3) {
    fbb_.AddElement<int32_t>(TestFunc1_args::VT_M_ARG3, m_arg3);
  }
  void add_m_arg4(uint64_t m_arg4) {
    fbb_.AddElement<uint64_t>(TestFunc1_args::VT_M_ARG4, m_arg4);
  }
  void add_m_arg5(::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers> m_arg5) {
    fbb_.AddOffset(TestFunc1_args::VT_M_ARG5, m_arg5);
  }
  void add_m_arg6(::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers> m_arg6) {
    fbb_.AddOffset(TestFunc1_args::VT_M_ARG6, m_arg6);
  }
  void add_m_arg7(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers>>> m_arg7) {
    fbb_.AddOffset(TestFunc1_args::VT_M_ARG7, m_arg7);
  }
  void add_m_arg8(::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> m_arg8) {
    fbb_.AddOffset(TestFunc1_args::VT_M_ARG8, m_arg8);
  }
  void add_m_arg9(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FlatbuffersDevTypes::WString>>> m_arg9) {
    fbb_.AddOffset(TestFunc1_args::VT_M_ARG9, m_arg9);
  }
  explicit TestFunc1_argsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TestFunc1_args> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TestFunc1_args>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TestFunc1_args> CreateTestFunc1_args(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t m__return_value_ = 0,
    bool m_arg1 = false,
    ::flatbuffers::Optional<uint32_t> m_arg2 = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<int32_t> m_arg3 = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<uint64_t> m_arg4 = ::flatbuffers::nullopt,
    ::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers> m_arg5 = 0,
    ::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers> m_arg6 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers>>> m_arg7 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> m_arg8 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FlatbuffersDevTypes::WString>>> m_arg9 = 0) {
  TestFunc1_argsBuilder builder_(_fbb);
  if(m_arg4) { builder_.add_m_arg4(*m_arg4); }
  builder_.add_m_arg9(m_arg9);
  builder_.add_m_arg8(m_arg8);
  builder_.add_m_arg7(m_arg7);
  builder_.add_m_arg6(m_arg6);
  builder_.add_m_arg5(m_arg5);
  if(m_arg3) { builder_.add_m_arg3(*m_arg3); }
  if(m_arg2) { builder_.add_m_arg2(*m_arg2); }
  builder_.add_m__return_value_(m__return_value_);
  builder_.add_m_arg1(m_arg1);
  return builder_.Finish();
}

struct TestFunc1_args::Traits {
  using type = TestFunc1_args;
  static auto constexpr Create = CreateTestFunc1_args;
};

inline ::flatbuffers::Offset<TestFunc1_args> CreateTestFunc1_argsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t m__return_value_ = 0,
    bool m_arg1 = false,
    ::flatbuffers::Optional<uint32_t> m_arg2 = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<int32_t> m_arg3 = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<uint64_t> m_arg4 = ::flatbuffers::nullopt,
    ::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers> m_arg5 = 0,
    ::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers> m_arg6 = 0,
    const std::vector<::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers>> *m_arg7 = nullptr,
    const std::vector<int16_t> *m_arg8 = nullptr,
    const std::vector<::flatbuffers::Offset<FlatbuffersDevTypes::WString>> *m_arg9 = nullptr) {
  auto m_arg7__ = m_arg7 ? _fbb.CreateVector<::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers>>(*m_arg7) : 0;
  auto m_arg8__ = m_arg8 ? _fbb.CreateVector<int16_t>(*m_arg8) : 0;
  auto m_arg9__ = m_arg9 ? _fbb.CreateVector<::flatbuffers::Offset<FlatbuffersDevTypes::WString>>(*m_arg9) : 0;
  return FlatbuffersDevTypes::CreateTestFunc1_args(
      _fbb,
      m__return_value_,
      m_arg1,
      m_arg2,
      m_arg3,
      m_arg4,
      m_arg5,
      m_arg6,
      m_arg7__,
      m_arg8__,
      m_arg9__);
}

::flatbuffers::Offset<TestFunc1_args> CreateTestFunc1_args(::flatbuffers::FlatBufferBuilder &_fbb, const TestFunc1_argsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WStringT : public ::flatbuffers::NativeTable {
  typedef WString TableType;
  std::vector<int16_t> wchars{};
};

struct WString FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WStringT NativeTableType;
  typedef WStringBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WCHARS = 4
  };
  const ::flatbuffers::Vector<int16_t> *wchars() const {
    return GetPointer<const ::flatbuffers::Vector<int16_t> *>(VT_WCHARS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WCHARS) &&
           verifier.VerifyVector(wchars()) &&
           verifier.EndTable();
  }
  WStringT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WStringT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WString> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WStringT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WStringBuilder {
  typedef WString Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_wchars(::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> wchars) {
    fbb_.AddOffset(WString::VT_WCHARS, wchars);
  }
  explicit WStringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WString>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WString> CreateWString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> wchars = 0) {
  WStringBuilder builder_(_fbb);
  builder_.add_wchars(wchars);
  return builder_.Finish();
}

struct WString::Traits {
  using type = WString;
  static auto constexpr Create = CreateWString;
};

inline ::flatbuffers::Offset<WString> CreateWStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int16_t> *wchars = nullptr) {
  auto wchars__ = wchars ? _fbb.CreateVector<int16_t>(*wchars) : 0;
  return FlatbuffersDevTypes::CreateWString(
      _fbb,
      wchars__);
}

::flatbuffers::Offset<WString> CreateWString(::flatbuffers::FlatBufferBuilder &_fbb, const WStringT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AbiRegisterVtl0Callbacks_argsT : public ::flatbuffers::NativeTable {
  typedef AbiRegisterVtl0Callbacks_args TableType;
  std::vector<uint64_t> callback_addresses{};
  std::vector<std::string> callback_names{};
  int32_t m__return_value_ = 0;
};

struct AbiRegisterVtl0Callbacks_args FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AbiRegisterVtl0Callbacks_argsT NativeTableType;
  typedef AbiRegisterVtl0Callbacks_argsBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CALLBACK_ADDRESSES = 4,
    VT_CALLBACK_NAMES = 6,
    VT_M__RETURN_VALUE_ = 8
  };
  const ::flatbuffers::Vector<uint64_t> *callback_addresses() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_CALLBACK_ADDRESSES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *callback_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CALLBACK_NAMES);
  }
  int32_t m__return_value_() const {
    return GetField<int32_t>(VT_M__RETURN_VALUE_, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CALLBACK_ADDRESSES) &&
           verifier.VerifyVector(callback_addresses()) &&
           VerifyOffset(verifier, VT_CALLBACK_NAMES) &&
           verifier.VerifyVector(callback_names()) &&
           verifier.VerifyVectorOfStrings(callback_names()) &&
           VerifyField<int32_t>(verifier, VT_M__RETURN_VALUE_, 4) &&
           verifier.EndTable();
  }
  AbiRegisterVtl0Callbacks_argsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AbiRegisterVtl0Callbacks_argsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AbiRegisterVtl0Callbacks_args> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AbiRegisterVtl0Callbacks_argsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AbiRegisterVtl0Callbacks_argsBuilder {
  typedef AbiRegisterVtl0Callbacks_args Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_callback_addresses(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> callback_addresses) {
    fbb_.AddOffset(AbiRegisterVtl0Callbacks_args::VT_CALLBACK_ADDRESSES, callback_addresses);
  }
  void add_callback_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> callback_names) {
    fbb_.AddOffset(AbiRegisterVtl0Callbacks_args::VT_CALLBACK_NAMES, callback_names);
  }
  void add_m__return_value_(int32_t m__return_value_) {
    fbb_.AddElement<int32_t>(AbiRegisterVtl0Callbacks_args::VT_M__RETURN_VALUE_, m__return_value_, 0);
  }
  explicit AbiRegisterVtl0Callbacks_argsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AbiRegisterVtl0Callbacks_args> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AbiRegisterVtl0Callbacks_args>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AbiRegisterVtl0Callbacks_args> CreateAbiRegisterVtl0Callbacks_args(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> callback_addresses = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> callback_names = 0,
    int32_t m__return_value_ = 0) {
  AbiRegisterVtl0Callbacks_argsBuilder builder_(_fbb);
  builder_.add_m__return_value_(m__return_value_);
  builder_.add_callback_names(callback_names);
  builder_.add_callback_addresses(callback_addresses);
  return builder_.Finish();
}

struct AbiRegisterVtl0Callbacks_args::Traits {
  using type = AbiRegisterVtl0Callbacks_args;
  static auto constexpr Create = CreateAbiRegisterVtl0Callbacks_args;
};

inline ::flatbuffers::Offset<AbiRegisterVtl0Callbacks_args> CreateAbiRegisterVtl0Callbacks_argsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *callback_addresses = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *callback_names = nullptr,
    int32_t m__return_value_ = 0) {
  auto callback_addresses__ = callback_addresses ? _fbb.CreateVector<uint64_t>(*callback_addresses) : 0;
  auto callback_names__ = callback_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*callback_names) : 0;
  return FlatbuffersDevTypes::CreateAbiRegisterVtl0Callbacks_args(
      _fbb,
      callback_addresses__,
      callback_names__,
      m__return_value_);
}

::flatbuffers::Offset<AbiRegisterVtl0Callbacks_args> CreateAbiRegisterVtl0Callbacks_args(::flatbuffers::FlatBufferBuilder &_fbb, const AbiRegisterVtl0Callbacks_argsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct __root_tableT : public ::flatbuffers::NativeTable {
  typedef __root_table TableType;
};

struct __root_table FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef __root_tableT NativeTableType;
  typedef __root_tableBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  __root_tableT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(__root_tableT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<__root_table> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const __root_tableT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct __root_tableBuilder {
  typedef __root_table Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit __root_tableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<__root_table> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<__root_table>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<__root_table> Create__root_table(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  __root_tableBuilder builder_(_fbb);
  return builder_.Finish();
}

struct __root_table::Traits {
  using type = __root_table;
  static auto constexpr Create = Create__root_table;
};

::flatbuffers::Offset<__root_table> Create__root_table(::flatbuffers::FlatBufferBuilder &_fbb, const __root_tableT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TestStruct1T *TestStruct1::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TestStruct1T>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TestStruct1::UnPackTo(TestStruct1T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = int64_val(); _o->int64_val = _e; }
  { auto _e = uint64_val(); _o->uint64_val = _e; }
  { auto _e = array1(); if (_e) { _o->array1.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->array1[_i] = _e->Get(_i); } } else { _o->array1.resize(0); } }
}

inline ::flatbuffers::Offset<TestStruct1> TestStruct1::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TestStruct1T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTestStruct1(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TestStruct1> CreateTestStruct1(::flatbuffers::FlatBufferBuilder &_fbb, const TestStruct1T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TestStruct1T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _int64_val = _o->int64_val;
  auto _uint64_val = _o->uint64_val;
  auto _array1 = _fbb.CreateVector(_o->array1);
  return FlatbuffersDevTypes::CreateTestStruct1(
      _fbb,
      _int64_val,
      _uint64_val,
      _array1);
}

inline NestedStructWithPointersT::NestedStructWithPointersT(const NestedStructWithPointersT &o)
      : int32_ptr(o.int32_ptr),
        struct_ptr((o.struct_ptr) ? new FlatbuffersDevTypes::TestStruct1T(*o.struct_ptr) : nullptr) {
}

inline NestedStructWithPointersT &NestedStructWithPointersT::operator=(NestedStructWithPointersT o) FLATBUFFERS_NOEXCEPT {
  std::swap(int32_ptr, o.int32_ptr);
  std::swap(struct_ptr, o.struct_ptr);
  return *this;
}

inline NestedStructWithPointersT *NestedStructWithPointers::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<NestedStructWithPointersT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NestedStructWithPointers::UnPackTo(NestedStructWithPointersT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = int32_ptr(); _o->int32_ptr = _e; }
  { auto _e = struct_ptr(); if (_e) { if(_o->struct_ptr) { _e->UnPackTo(_o->struct_ptr.get(), _resolver); } else { _o->struct_ptr = std::unique_ptr<FlatbuffersDevTypes::TestStruct1T>(_e->UnPack(_resolver)); } } else if (_o->struct_ptr) { _o->struct_ptr.reset(); } }
}

inline ::flatbuffers::Offset<NestedStructWithPointers> NestedStructWithPointers::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NestedStructWithPointersT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNestedStructWithPointers(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NestedStructWithPointers> CreateNestedStructWithPointers(::flatbuffers::FlatBufferBuilder &_fbb, const NestedStructWithPointersT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NestedStructWithPointersT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _int32_ptr = _o->int32_ptr;
  auto _struct_ptr = _o->struct_ptr ? CreateTestStruct1(_fbb, _o->struct_ptr.get(), _rehasher) : 0;
  return FlatbuffersDevTypes::CreateNestedStructWithPointers(
      _fbb,
      _int32_ptr,
      _struct_ptr);
}

inline StructWithPointersT::StructWithPointersT(const StructWithPointersT &o)
      : nested_struct_ptr((o.nested_struct_ptr) ? new FlatbuffersDevTypes::NestedStructWithPointersT(*o.nested_struct_ptr) : nullptr) {
}

inline StructWithPointersT &StructWithPointersT::operator=(StructWithPointersT o) FLATBUFFERS_NOEXCEPT {
  std::swap(nested_struct_ptr, o.nested_struct_ptr);
  return *this;
}

inline StructWithPointersT *StructWithPointers::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StructWithPointersT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StructWithPointers::UnPackTo(StructWithPointersT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nested_struct_ptr(); if (_e) { if(_o->nested_struct_ptr) { _e->UnPackTo(_o->nested_struct_ptr.get(), _resolver); } else { _o->nested_struct_ptr = std::unique_ptr<FlatbuffersDevTypes::NestedStructWithPointersT>(_e->UnPack(_resolver)); } } else if (_o->nested_struct_ptr) { _o->nested_struct_ptr.reset(); } }
}

inline ::flatbuffers::Offset<StructWithPointers> StructWithPointers::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StructWithPointersT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStructWithPointers(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StructWithPointers> CreateStructWithPointers(::flatbuffers::FlatBufferBuilder &_fbb, const StructWithPointersT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StructWithPointersT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nested_struct_ptr = _o->nested_struct_ptr ? CreateNestedStructWithPointers(_fbb, _o->nested_struct_ptr.get(), _rehasher) : 0;
  return FlatbuffersDevTypes::CreateStructWithPointers(
      _fbb,
      _nested_struct_ptr);
}

inline TestFunc0_argsT::TestFunc0_argsT(const TestFunc0_argsT &o)
      : m__return_value_(o.m__return_value_),
        m_arg1(o.m_arg1),
        m_arg2(o.m_arg2),
        m_arg3(o.m_arg3),
        m_arg4(o.m_arg4),
        m_arg5((o.m_arg5) ? new FlatbuffersDevTypes::StructWithPointersT(*o.m_arg5) : nullptr),
        m_arg6((o.m_arg6) ? new FlatbuffersDevTypes::StructWithPointersT(*o.m_arg6) : nullptr),
        m_arg7(o.m_arg7),
        m_arg8(o.m_arg8),
        m_arg9(o.m_arg9) {
}

inline TestFunc0_argsT &TestFunc0_argsT::operator=(TestFunc0_argsT o) FLATBUFFERS_NOEXCEPT {
  std::swap(m__return_value_, o.m__return_value_);
  std::swap(m_arg1, o.m_arg1);
  std::swap(m_arg2, o.m_arg2);
  std::swap(m_arg3, o.m_arg3);
  std::swap(m_arg4, o.m_arg4);
  std::swap(m_arg5, o.m_arg5);
  std::swap(m_arg6, o.m_arg6);
  std::swap(m_arg7, o.m_arg7);
  std::swap(m_arg8, o.m_arg8);
  std::swap(m_arg9, o.m_arg9);
  return *this;
}

inline TestFunc0_argsT *TestFunc0_args::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TestFunc0_argsT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TestFunc0_args::UnPackTo(TestFunc0_argsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = m__return_value_(); _o->m__return_value_ = _e; }
  { auto _e = m_arg1(); _o->m_arg1 = _e; }
  { auto _e = m_arg2(); _o->m_arg2 = _e; }
  { auto _e = m_arg3(); _o->m_arg3 = _e; }
  { auto _e = m_arg4(); _o->m_arg4 = _e; }
  { auto _e = m_arg5(); if (_e) { if(_o->m_arg5) { _e->UnPackTo(_o->m_arg5.get(), _resolver); } else { _o->m_arg5 = std::unique_ptr<FlatbuffersDevTypes::StructWithPointersT>(_e->UnPack(_resolver)); } } else if (_o->m_arg5) { _o->m_arg5.reset(); } }
  { auto _e = m_arg6(); if (_e) { if(_o->m_arg6) { _e->UnPackTo(_o->m_arg6.get(), _resolver); } else { _o->m_arg6 = std::unique_ptr<FlatbuffersDevTypes::StructWithPointersT>(_e->UnPack(_resolver)); } } else if (_o->m_arg6) { _o->m_arg6.reset(); } }
  { auto _e = m_arg7(); if (_e) { _o->m_arg7.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->m_arg7[_i] = *std::unique_ptr<FlatbuffersDevTypes::StructWithPointersT>(_e->Get(_i)->UnPack(_resolver)); } } else { _o->m_arg7.resize(0); } }
  { auto _e = m_arg8(); if (_e) { _o->m_arg8.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->m_arg8[_i] = _e->Get(_i); } } else { _o->m_arg8.resize(0); } }
  { auto _e = m_arg9(); if (_e) { _o->m_arg9.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->m_arg9[_i] = *std::unique_ptr<FlatbuffersDevTypes::WStringT>(_e->Get(_i)->UnPack(_resolver)); } } else { _o->m_arg9.resize(0); } }
}

inline ::flatbuffers::Offset<TestFunc0_args> TestFunc0_args::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TestFunc0_argsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTestFunc0_args(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TestFunc0_args> CreateTestFunc0_args(::flatbuffers::FlatBufferBuilder &_fbb, const TestFunc0_argsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TestFunc0_argsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _m__return_value_ = _o->m__return_value_;
  auto _m_arg1 = _o->m_arg1;
  auto _m_arg2 = _o->m_arg2;
  auto _m_arg3 = _o->m_arg3;
  auto _m_arg4 = _o->m_arg4;
  auto _m_arg5 = _o->m_arg5 ? CreateStructWithPointers(_fbb, _o->m_arg5.get(), _rehasher) : 0;
  auto _m_arg6 = _o->m_arg6 ? CreateStructWithPointers(_fbb, _o->m_arg6.get(), _rehasher) : 0;
  auto _m_arg7 = _fbb.CreateVector<::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers>> (_o->m_arg7.size(), [](size_t i, _VectorArgs *__va) { return CreateStructWithPointers(*__va->__fbb, &(__va->__o->m_arg7[i]), __va->__rehasher); }, &_va );
  auto _m_arg8 = _fbb.CreateVector(_o->m_arg8);
  auto _m_arg9 = _fbb.CreateVector<::flatbuffers::Offset<FlatbuffersDevTypes::WString>> (_o->m_arg9.size(), [](size_t i, _VectorArgs *__va) { return CreateWString(*__va->__fbb, &(__va->__o->m_arg9[i]), __va->__rehasher); }, &_va );
  return FlatbuffersDevTypes::CreateTestFunc0_args(
      _fbb,
      _m__return_value_,
      _m_arg1,
      _m_arg2,
      _m_arg3,
      _m_arg4,
      _m_arg5,
      _m_arg6,
      _m_arg7,
      _m_arg8,
      _m_arg9);
}

inline TestFunc1_argsT::TestFunc1_argsT(const TestFunc1_argsT &o)
      : m__return_value_(o.m__return_value_),
        m_arg1(o.m_arg1),
        m_arg2(o.m_arg2),
        m_arg3(o.m_arg3),
        m_arg4(o.m_arg4),
        m_arg5((o.m_arg5) ? new FlatbuffersDevTypes::StructWithPointersT(*o.m_arg5) : nullptr),
        m_arg6((o.m_arg6) ? new FlatbuffersDevTypes::StructWithPointersT(*o.m_arg6) : nullptr),
        m_arg7(o.m_arg7),
        m_arg8(o.m_arg8),
        m_arg9(o.m_arg9) {
}

inline TestFunc1_argsT &TestFunc1_argsT::operator=(TestFunc1_argsT o) FLATBUFFERS_NOEXCEPT {
  std::swap(m__return_value_, o.m__return_value_);
  std::swap(m_arg1, o.m_arg1);
  std::swap(m_arg2, o.m_arg2);
  std::swap(m_arg3, o.m_arg3);
  std::swap(m_arg4, o.m_arg4);
  std::swap(m_arg5, o.m_arg5);
  std::swap(m_arg6, o.m_arg6);
  std::swap(m_arg7, o.m_arg7);
  std::swap(m_arg8, o.m_arg8);
  std::swap(m_arg9, o.m_arg9);
  return *this;
}

inline TestFunc1_argsT *TestFunc1_args::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TestFunc1_argsT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TestFunc1_args::UnPackTo(TestFunc1_argsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = m__return_value_(); _o->m__return_value_ = _e; }
  { auto _e = m_arg1(); _o->m_arg1 = _e; }
  { auto _e = m_arg2(); _o->m_arg2 = _e; }
  { auto _e = m_arg3(); _o->m_arg3 = _e; }
  { auto _e = m_arg4(); _o->m_arg4 = _e; }
  { auto _e = m_arg5(); if (_e) { if(_o->m_arg5) { _e->UnPackTo(_o->m_arg5.get(), _resolver); } else { _o->m_arg5 = std::unique_ptr<FlatbuffersDevTypes::StructWithPointersT>(_e->UnPack(_resolver)); } } else if (_o->m_arg5) { _o->m_arg5.reset(); } }
  { auto _e = m_arg6(); if (_e) { if(_o->m_arg6) { _e->UnPackTo(_o->m_arg6.get(), _resolver); } else { _o->m_arg6 = std::unique_ptr<FlatbuffersDevTypes::StructWithPointersT>(_e->UnPack(_resolver)); } } else if (_o->m_arg6) { _o->m_arg6.reset(); } }
  { auto _e = m_arg7(); if (_e) { _o->m_arg7.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->m_arg7[_i] = *std::unique_ptr<FlatbuffersDevTypes::StructWithPointersT>(_e->Get(_i)->UnPack(_resolver)); } } else { _o->m_arg7.resize(0); } }
  { auto _e = m_arg8(); if (_e) { _o->m_arg8.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->m_arg8[_i] = _e->Get(_i); } } else { _o->m_arg8.resize(0); } }
  { auto _e = m_arg9(); if (_e) { _o->m_arg9.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->m_arg9[_i] = *std::unique_ptr<FlatbuffersDevTypes::WStringT>(_e->Get(_i)->UnPack(_resolver)); } } else { _o->m_arg9.resize(0); } }
}

inline ::flatbuffers::Offset<TestFunc1_args> TestFunc1_args::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TestFunc1_argsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTestFunc1_args(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TestFunc1_args> CreateTestFunc1_args(::flatbuffers::FlatBufferBuilder &_fbb, const TestFunc1_argsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TestFunc1_argsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _m__return_value_ = _o->m__return_value_;
  auto _m_arg1 = _o->m_arg1;
  auto _m_arg2 = _o->m_arg2;
  auto _m_arg3 = _o->m_arg3;
  auto _m_arg4 = _o->m_arg4;
  auto _m_arg5 = _o->m_arg5 ? CreateStructWithPointers(_fbb, _o->m_arg5.get(), _rehasher) : 0;
  auto _m_arg6 = _o->m_arg6 ? CreateStructWithPointers(_fbb, _o->m_arg6.get(), _rehasher) : 0;
  auto _m_arg7 = _fbb.CreateVector<::flatbuffers::Offset<FlatbuffersDevTypes::StructWithPointers>> (_o->m_arg7.size(), [](size_t i, _VectorArgs *__va) { return CreateStructWithPointers(*__va->__fbb, &(__va->__o->m_arg7[i]), __va->__rehasher); }, &_va );
  auto _m_arg8 = _fbb.CreateVector(_o->m_arg8);
  auto _m_arg9 = _fbb.CreateVector<::flatbuffers::Offset<FlatbuffersDevTypes::WString>> (_o->m_arg9.size(), [](size_t i, _VectorArgs *__va) { return CreateWString(*__va->__fbb, &(__va->__o->m_arg9[i]), __va->__rehasher); }, &_va );
  return FlatbuffersDevTypes::CreateTestFunc1_args(
      _fbb,
      _m__return_value_,
      _m_arg1,
      _m_arg2,
      _m_arg3,
      _m_arg4,
      _m_arg5,
      _m_arg6,
      _m_arg7,
      _m_arg8,
      _m_arg9);
}

inline WStringT *WString::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<WStringT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WString::UnPackTo(WStringT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = wchars(); if (_e) { _o->wchars.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->wchars[_i] = _e->Get(_i); } } else { _o->wchars.resize(0); } }
}

inline ::flatbuffers::Offset<WString> WString::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WStringT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWString(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WString> CreateWString(::flatbuffers::FlatBufferBuilder &_fbb, const WStringT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WStringT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _wchars = _fbb.CreateVector(_o->wchars);
  return FlatbuffersDevTypes::CreateWString(
      _fbb,
      _wchars);
}

inline AbiRegisterVtl0Callbacks_argsT *AbiRegisterVtl0Callbacks_args::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<AbiRegisterVtl0Callbacks_argsT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AbiRegisterVtl0Callbacks_args::UnPackTo(AbiRegisterVtl0Callbacks_argsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = callback_addresses(); if (_e) { _o->callback_addresses.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->callback_addresses[_i] = _e->Get(_i); } } else { _o->callback_addresses.resize(0); } }
  { auto _e = callback_names(); if (_e) { _o->callback_names.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->callback_names[_i] = _e->Get(_i)->str(); } } else { _o->callback_names.resize(0); } }
  { auto _e = m__return_value_(); _o->m__return_value_ = _e; }
}

inline ::flatbuffers::Offset<AbiRegisterVtl0Callbacks_args> AbiRegisterVtl0Callbacks_args::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AbiRegisterVtl0Callbacks_argsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAbiRegisterVtl0Callbacks_args(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AbiRegisterVtl0Callbacks_args> CreateAbiRegisterVtl0Callbacks_args(::flatbuffers::FlatBufferBuilder &_fbb, const AbiRegisterVtl0Callbacks_argsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AbiRegisterVtl0Callbacks_argsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _callback_addresses = _fbb.CreateVector(_o->callback_addresses);
  auto _callback_names = _fbb.CreateVectorOfStrings(_o->callback_names);
  auto _m__return_value_ = _o->m__return_value_;
  return FlatbuffersDevTypes::CreateAbiRegisterVtl0Callbacks_args(
      _fbb,
      _callback_addresses,
      _callback_names,
      _m__return_value_);
}

inline __root_tableT *__root_table::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<__root_tableT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void __root_table::UnPackTo(__root_tableT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<__root_table> __root_table::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const __root_tableT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Create__root_table(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<__root_table> Create__root_table(::flatbuffers::FlatBufferBuilder &_fbb, const __root_tableT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const __root_tableT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return FlatbuffersDevTypes::Create__root_table(
      _fbb);
}

inline const FlatbuffersDevTypes::__root_table *Get__root_table(const void *buf) {
  return ::flatbuffers::GetRoot<FlatbuffersDevTypes::__root_table>(buf);
}

inline const FlatbuffersDevTypes::__root_table *GetSizePrefixed__root_table(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<FlatbuffersDevTypes::__root_table>(buf);
}

inline bool Verify__root_tableBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<FlatbuffersDevTypes::__root_table>(nullptr);
}

inline bool VerifySizePrefixed__root_tableBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<FlatbuffersDevTypes::__root_table>(nullptr);
}

inline void Finish__root_tableBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<FlatbuffersDevTypes::__root_table> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixed__root_tableBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<FlatbuffersDevTypes::__root_table> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<FlatbuffersDevTypes::__root_tableT> UnPack__root_table(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<FlatbuffersDevTypes::__root_tableT>(Get__root_table(buf)->UnPack(res));
}

inline std::unique_ptr<FlatbuffersDevTypes::__root_tableT> UnPackSizePrefixed__root_table(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<FlatbuffersDevTypes::__root_tableT>(GetSizePrefixed__root_table(buf)->UnPack(res));
}

}  // namespace FlatbuffersDevTypes

#endif  // FLATBUFFERS_GENERATED_VBSENCLAVEFLATBUFFERSUPPORT_FLATBUFFERSDEVTYPES_H_
