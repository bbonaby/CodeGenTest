// This file was auto-generated by edlcodegen.exe
// Changes to this file may be lost if the file is regenerated.
#pragma once
#include <VbsEnclaveABI\Host\HostHelpers.h>
#include "DeveloperTypes.h"
using namespace VbsEnclaveABI;
using namespace VbsEnclaveABI::Shared;
using namespace VbsEnclaveABI::HostApp;
using namespace DeveloperTypes;


namespace CodeGenTest
{
    namespace VTL0_Stubs
    {
        using namespace VbsEnclaveABI::Shared::Converters;

        struct CodeGenTestClass
        
{

            CodeGenTestClass(LPVOID enclave) : m_enclave(enclave)
            {
            }

            
        public:

        /*****************************************************
         *    VTL0 Generated Developer Method Declarations   *
        ******************************************************/
        
        static HRESULT TestFunc_callback(_In_  bool arg1, _In_ const uint32_t* arg2, _Inout_  int32_t* arg3, _Out_  std::unique_ptr<uint64_t>& arg4, _Inout_  StructWithPointers& arg5, _Out_  std::unique_ptr<StructWithPointers>& arg6, _Inout_  std::vector<StructWithPointers>& arg7, _Out_  std::vector<std::int16_t>& arg8, _Out_  std::array<std::wstring, 2>& arg9);

        HRESULT RegisterVtl0Callbacks()
        {
            auto lock = m_register_callbacks_lock.lock_exclusive();

            if (m_callbacks_registered)
            {
                return S_OK;
            }

            FlatbuffersDevTypes::AbiRegisterVtl0Callbacks_argsT input {};
            input.callback_addresses.assign(m_callback_addresses.begin(), m_callback_addresses.end());
            input.callback_names.assign(m_callback_names.begin(), m_callback_names.end());
            flatbuffers::FlatBufferBuilder builder = PackFlatbuffer(input);
            using ReturnParamsT = FlatbuffersDevTypes::AbiRegisterVtl0Callbacks_argsT;
            ReturnParamsT out_args {};

            HRESULT hr = CallVtl1ExportFromVtl0<ReturnParamsT>(
                m_enclave,
                "__AbiRegisterVtl0Callbacks_CodeGenTest__",
                builder,
                out_args);
            RETURN_IF_FAILED(hr);

            if (SUCCEEDED(out_args.m__return_value_))
            {
                m_callbacks_registered = true;
            }

            return out_args.m__return_value_;
        }

        public:

        /************************************************************
         *    VTL0 Side Of VTL1 Developer Function Implementations  *
        *************************************************************/
        
        HRESULT TestFunc(_In_  bool arg1, _In_ const uint32_t* arg2, _Inout_  int32_t* arg3, _Out_  std::unique_ptr<uint64_t>& arg4, _Inout_  StructWithPointers& arg5, _Out_  std::unique_ptr<StructWithPointers>& arg6, _Inout_  std::vector<StructWithPointers>& arg7, _Out_  std::vector<std::int16_t>& arg8, _Out_  std::array<std::wstring, 2>& arg9)
        {
            // Package in and in/out parameters into struct and convert it to a flatbuffer type.
            FlatbuffersDevTypes::TestFunc0_argsT in_flatbufferT {};
            in_flatbufferT.m_arg1 = ConvertType<decltype(in_flatbufferT.m_arg1)>(arg1);
            in_flatbufferT.m_arg2 = ConvertType<decltype(in_flatbufferT.m_arg2)>(arg2);
            in_flatbufferT.m_arg3 = ConvertType<decltype(in_flatbufferT.m_arg3)>(arg3);
            in_flatbufferT.m_arg5 = ConvertType<decltype(in_flatbufferT.m_arg5)>(arg5);
            in_flatbufferT.m_arg7 = ConvertType<decltype(in_flatbufferT.m_arg7)>(arg7);
            in_flatbufferT.m_arg9 = ConvertType<decltype(in_flatbufferT.m_arg9)>(arg9);

            using ParamsT = decltype(in_flatbufferT);
            auto flatbuffer_builder = PackFlatbuffer(in_flatbufferT);
            using ReturnParamsT = FlatbuffersDevTypes::TestFunc0_argsT;
            auto function_result = ReturnParamsT();
            THROW_IF_FAILED((CallVtl1ExportFromVtl0<ReturnParamsT>(m_enclave, "TestFunc0_Generated_Stub", flatbuffer_builder, function_result)));
            
            auto return_params = ConvertStruct<TestFunc0_args>(function_result);
            UpdateParameterValue(return_params.m_arg3, arg3);
            UpdateParameterValue(return_params.m_arg4, arg4);
            UpdateParameterValue(return_params.m_arg5, arg5);
            UpdateParameterValue(return_params.m_arg6, arg6);
            UpdateParameterValue(return_params.m_arg7, arg7);
            UpdateParameterValue(return_params.m_arg8, arg8);
            UpdateParameterValue(return_params.m_arg9, arg9);
            return std::move(return_params.m__return_value_);

        }

            
        private:

        /***********************************************
         *    VTL0 Generated ABI Boundary Callbacks    *
        ************************************************/
        
        static inline void* TestFunc1_Generated_Stub(void* function_context)
        try
        {
            using ParamsT = FlatbuffersDevTypes::TestFunc1_argsT;
            using ReturnParamsT = FlatbuffersDevTypes::TestFunc1_argsT;
            
            HRESULT hr = CallVtl0CallbackImplFromVtl0<ParamsT, ReturnParamsT, decltype(TestFunc1_Abi_Impl)>(function_context, TestFunc1_Abi_Impl);
            LOG_IF_FAILED(hr);
            return ABI_HRESULT_TO_PVOID(hr);
        }
        catch (...)
        {
            HRESULT hr = wil::ResultFromCaughtException();
            LOG_IF_FAILED(hr);
            return ABI_HRESULT_TO_PVOID(hr);
        }

        /*****************************************************
         *    VTL0 Generated ABI Implementation Callbacks    *
        ******************************************************/
        
        static inline void TestFunc1_Abi_Impl(_In_ FlatbuffersDevTypes::TestFunc1_argsT& in_flatbuffer_params, _In_ flatbuffers::FlatBufferBuilder& flatbuffer_out_params_builder)
        {
            auto dev_type_params = ConvertStruct<TestFunc1_args>(in_flatbuffer_params);
            dev_type_params.m__return_value_ = TestFunc_callback( dev_type_params.m_arg1, dev_type_params.m_arg2.get(), dev_type_params.m_arg3.get(), dev_type_params.m_arg4, dev_type_params.m_arg5, dev_type_params.m_arg6, dev_type_params.m_arg7, dev_type_params.m_arg8, dev_type_params.m_arg9);

            auto flatbuffer_out_param = ConvertStruct<decltype(in_flatbuffer_params)>(dev_type_params);
            flatbuffer_out_params_builder = PackFlatbuffer(flatbuffer_out_param);
        }

        private:
            LPVOID m_enclave{};
            bool m_callbacks_registered{};
            wil::srwlock m_register_callbacks_lock{};
            std::array<uintptr_t, 3> m_callback_addresses{ reinterpret_cast<uintptr_t>(&VbsEnclaveABI::HostApp::AllocateVtl0MemoryCallback),reinterpret_cast<uintptr_t>(&VbsEnclaveABI::HostApp::DeallocateVtl0MemoryCallback), reinterpret_cast<uintptr_t>(&TestFunc1_Generated_Stub) };
            std::array<std::string, 3> m_callback_names{ "VbsEnclaveABI::HostApp::AllocateVtl0MemoryCallback","VbsEnclaveABI::HostApp::DeallocateVtl0MemoryCallback", "CodeGenTest::CodeGenTestClass::TestFunc1_Generated_Stub" };

        };


    }
}
